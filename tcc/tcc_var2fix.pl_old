#!/usr/bin/perl
#
# var2fix.pl - Macro generator for variable parameters to fixed parameters
#              conversion
#
# Written 2001 by Werner Almesberger
# Copyright 2001 Network Robots
#


#
# We use a spectacularly ugly and restrictive macro language syntax, which
# just happens to be quite easy to parse in Perl.
#
# It goes as follow:
#
# #map <macro_name>(<free_params...>) <next_macro>
# #map <macro_name>(<fixed_params...>,,<free_params>) <next_macro>
#
# (notice the double comma between fixed_params and free_params)
#
# where <fixed_params> is <word>,...
# and <free_params> is <word>=<value>,... 
#
# <value> must not contain commas or parentheses.
#
# A #map directive can be continued on following lines by ending unfinished
# lines with a backslash.
#

#
# Known problems:
#
# - optional parameters are always provided to the underlying construct.
#   The only thing we can do is to set them to a reasonable default value.
#   This is sufficient if
#    - the parameter defaults to a well-known default anyway
#      (e.g. dsmark "mask" or "value")
#    - the parameter is ignored in the given situation, and making it
#      optional just relieves the user from having to provide this
#      parameter pro forma (e.g. "mtu" in meters if not using the "tc"
#      target)
# - error messages for missing, unrecognized, or duplicate parameters can
#   be a little obscure, i.e. they are "invalid type conversion", "syntax
#   error", and "number/handle not valid here" or "invalid type
#   conversion" respectively
# - what follows below almost certainly isn't valid CPP input, e.g a##b
#   with "b" containing whitespace is suspicious. Fortunately, most
#   versions of GNU CPP don't seem to mind.
#


#
# The structure of the macros generated by var2fix needs a bit of explaining.
#
# The parameters are processed by one macro per parameter, which stores the
# parameter value in a variable and then invokes the macros for the next
# parameter. Note that CPP normaly does not allow recursion. We work around
# this by having one separate macro for each parameter, so it just works out.
#
# Example (using "new" syntax with semicolons):
#
# __set_SLB($var,cir 1Mbps,cbs 10kB);
#
# gets expanded in
# field __set_SLB_dummy = raw if (0 __m_set_SLB_##__VA_ARGS__);
# to
# field __set_SLB_dummy = raw if (0 __m_set_SLB_cir 1Mbps,cbs 10kB);
#
# __m_set_SLB_cir expands to __m_set_SLB_cir_2(,
# so we get
# field __set_SLB_dummy = raw if (0 __m_set_SLB_cir_2(1Mbps,cbs 10kB);
# and then
# field __set_SLB_dummy = raw if (0 );
# $__set_SLB_cir = 1Mbps
# field __set_SLB_dummy = raw if = (0 __m_set_SLB_cbs 10kB);
#
# This looks remarkably awkward, and it is. The purpose of the
# field __set_SLB_dummy = raw if (0
# is to swallow the closing parenthesis. We use a field instead of a variable
# assignment, because tcc never complains about unused fields.
#
# This may still seem needlessly complex, but we will see in a moment why
# things were done this way.
#
# "cir" is now handled, so the expansion proceeds in the same way for "cbs",
# i.e.
# ... field __set_SLB_dummy = raw if (0 __m_set_SLB_cbs 10kB);
# becomes
# ... field __set_SLB_dummy = raw if (0 __m_set_SLB_cbs_2(10kB);
#
# Now, the expansion of __m_set_SLB_cbs_2 unfortunately depends on the version
# of CPP. Older versions of GNU CPP remove __VA_ARGS__ and anything
# surrounding it if __VA_ARGS__ is empty. More recent versions of GNU CPP
# only remove a comma "concatenated" to __VA_ARGS__, but nothing else [1].
# So we get either
#
# ... field __set_SLB_dummy = raw if (0 );
# $__set_SLB_cir = val; field __set_SLB_dummy = raw if (0);
#
# (old CPP) or
#
# ... field __set_SLB_dummy = raw if (0 );
# $__set_SLB_cir = val; field __set_SLB_dummy = raw if = (0 __m_set_SLB_);
#
# (new CPP), where the __m_set_SLB_ at the end gets expanded to nothing,
# yielding the same expression as with old CPP.
#
# [1] http://gcc.gnu.org/onlinedocs/gcc-3.0/cpp_3.html#SEC19
#


sub expand
{
    local ($line) = @_;

    if ($line =~ /^#map\s+(\S+)\s*\(([^)]*),,([^)]*)\)\s+(\S+)\s*$/) {
	($name,$fixed,$free,$next) = ($1,$2,$3,$4)
    }
    elsif ($line =~ /^#map\s+(\S+)\s*\(([^)]*)\)\s+(\S+)\s*$/) {
	($name,$fixed,$free,$next) = ($1,"",$2,$3)
    }
    else {
	die "unrecognized syntax";
    }
    $fixed =~ s/\s+//g;
    $fixed .= "," unless $fixed eq "";
    print "#define __m_${name}_\n\n";
    undef $defaults;
    undef $use;
    undef $pass;
    for (split(",",$free)) {
	($param,$value) = split("=",$_);
	$param =~ s/^\s+//;
	$param =~ s/\s+$//;
	print "#define __m_${name}_${param}_2(val,...) \\\n";
	print "  )$semi \\\n";
        print "  \$__${name}_${param} = val$semi ".
	  "field __${name}_dummy = raw if (0 __m_${name}_##__VA_ARGS__)\n";
	print "#define __m_${name}_${param}  __m_${name}_${param}_2(\n\n";
	$defaults .= "  \$__${name}_${param} = $value$semi \\\n";
	$use .= "  field __${name}_dummy = raw ".
	  "if \$__${name}_${param} == \$__${name}_${param}$semi \\\n";
	$pass .= "\$__${name}_${param},";
    }
    chop($pass);
    print "#define __$name($fixed...) \\\n";
    print "  /* set defaults */ \\\n$defaults";
    print "  /* \"use\" all variables */ \\\n$use";
    print "  /* copy parameters to variables */ \\\n";
    print "  field __${name}_dummy = raw if (0 ".
      "__m_${name}_##__VA_ARGS__)$semi \\\n";
    print "  /* invoke next macro */ \\\n";
    print "  $next($fixed$pass)\n\n";
    print "#define $name(...) __$name(__VA_ARGS__) /* expand macros */\n";
}


$semi = ";";

if ($ARGV[0] =~ /^-/) {
    print STDERR "usage: $0 [-S] [file ...]\n";
    exit(1);
}

print "/* MACHINE-GENERATED. DO NOT EDIT ! */\n\n";

while (<>) {
    if (/^#map\s/) {
	chop;
	$line = $_;
	while ($line =~ /\s*\\\s*$/) {
	    $more = <>;
	    last unless defined $more;
	    chop($more);
	    $line = $`." ".$more;
	}
	&expand($line);
    }
    else {
	print;
    }
}
exit(0);
